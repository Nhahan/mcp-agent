# agent/state.py
from typing import TypedDict, List, Optional, Dict, Any, Tuple
from pydantic import BaseModel, Field, ConfigDict # Import ConfigDict
from langchain_core.tools import BaseTool # Import BaseTool for typing

# --- Pydantic Models for GBNF Grammar Generation (Matching YAML Structure) ---
class YamlToolCall(BaseModel):
    evidence_variable: str
    tool_name: str
    # Arguments field is a string because the prompt asks for a JSON string
    arguments: str

class YamlPlanStep(BaseModel):
    plan: str
    # tool_call can be YamlToolCall or null (represented as Optional)
    tool_call: Optional[YamlToolCall]

class YamlPlanOutput(BaseModel):
    steps: List[YamlPlanStep]
# --- End GBNF Pydantic Models ---


# --- Pydantic Models for LLM Plan Output ---
class ToolCallPydantic(BaseModel):
    """ Represents a planned tool call using Pydantic for structured output. """
    evidence_variable: str = Field(..., description="The variable name assigned to the tool output (e.g., '#E1').")
    tool_name: str = Field(..., description="The exact name of the tool to call.")
    arguments: Dict[str, Any] = Field(default_factory=dict, description="The arguments for the tool call as a JSON object.")
    evidence_input_key: Optional[str] = Field(None, description="If specified, use this input argument's value as evidence instead of the tool's direct output.")

    # Forbid extra fields in tool calls
    model_config = ConfigDict(extra='forbid')

class PlanStepPydantic(BaseModel):
    """ Represents a single step in the reasoning plan using Pydantic. """
    plan: str = Field(..., description="The reasoning or the direct content/instruction for this step.")
    tool_call: Optional[ToolCallPydantic] = Field(None, description="The tool call for this step, or null if no tool is needed.")

    # Forbid extra fields (like tool_name/arguments outside of tool_call)
    model_config = ConfigDict(extra='forbid')

class PlanOutputPydantic(BaseModel):
    """ Defines the structure for the entire plan generated by the LLM. """
    steps: List[PlanStepPydantic] = Field(..., description="The list of steps composing the plan.")

    # Forbid extra fields at the root level
    model_config = ConfigDict(extra='forbid')
# --- End Pydantic Models ---


# --- TypedDict Definitions for State and Internal Use ---
class ToolCall(TypedDict):
    """ Represents a planned tool call within the ReWOO plan. """
    tool_name: str # e.g., "web_search_placeholder/search"
    arguments: Dict[str, Any]

class ToolResult(TypedDict):
    """ Represents the output of a tool execution. """
    tool_name: str
    output: Any # The actual data returned by the tool
    error: Optional[str] # Any error message during execution

class PlanStep(TypedDict):
    """ Represents a single step in the reasoning plan. """
    step_index: int # 필드 이름을 step_index로 변경 및 통일
    thought: str
    # tool_call 필드 타입을 Optional[ToolCall] 로 수정
    tool_call: Optional[ToolCall]
    expected_outcome: str
    status: str # 'pending', 'in_progress', 'completed', 'failed'

class Evidence(TypedDict):
    """ Represents the evidence gathered from a tool execution, linked to a plan step. """
    step_index: int # The index of the plan step this evidence corresponds to (matches PlanStep.step_index)
    tool_result: ToolResult # The result of the tool execution
    processed_evidence: str # A summary or processed form of the tool output (potentially LLM generated)

# Representing parsed plan steps as tuples (for actual tool execution)
# (reasoning: str, evidence_variable: str, tool_name: str, tool_input: str)
ParsedPlanStep = Tuple[str, str, str, str]

# Evidence dictionary mapping evidence variable (#E1, #E2) to its string content
EvidenceDict = Dict[str, str]

# LangGraph State Definition
class ReWOOState(TypedDict):
    """
    Represents the state of the ReWOO agent workflow.
    """
    original_query: str
    
    # Tool related state - Full list from config, filtered list from filter node
    # Configurable provides the initial full list
    filtered_tools: Optional[List[BaseTool]] # Tools selected by the filter node
    filtered_tools_str: Optional[str] # Formatted string of filtered tools for the planner
    
    # Planning related state
    plan: Optional[List[ParsedPlanStep]]
    plan_pydantic: Optional[PlanOutputPydantic]
    raw_plan_output: Optional[str]
    all_parsed_steps: Optional[List[Dict[str, Any]]]
    current_step_index: int
    
    # Execution related state
    current_tool_call: Optional[Dict[str, Any]]
    prepared_tool_input: Optional[Any]
    evidence: EvidenceDict
    current_tool_invocation_inputs: Optional[Dict[str, Any]] # Inputs for the current tool call
    use_input_as_evidence: Optional[str] # Key of the input to use as evidence
    
    # Output and control flow state
    final_answer: Optional[str]
    error_message: Optional[str]
    max_retries: int
    current_retry: int
    workflow_status: Optional[str]
    next_node: Optional[str]

# Pydantic models removed as we parse plan text now
# class ToolCallPydantic(BaseModel): ...
# class PlanStepPydantic(BaseModel): ...
# class PlanOutput(BaseModel): ... 