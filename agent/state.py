# agent/state.py
from typing import TypedDict, List, Optional, Dict, Any, Union, Tuple
from pydantic import BaseModel, Field # Import pydantic
from langchain_core.tools import BaseTool # Assuming BaseTool might be needed

# --- Pydantic Models for LLM Plan Output ---
class ToolCallPydantic(BaseModel):
    """ Represents a planned tool call using Pydantic for structured output. """
    evidence_variable: str = Field(..., description="The variable name assigned to the tool output (e.g., '#E1').")
    tool_name: str = Field(..., description="The exact name of the tool to call.")
    arguments: Dict[str, Any] = Field(default_factory=dict, description="The arguments for the tool call as a JSON object.")

class PlanStepPydantic(BaseModel):
    """ Represents a single step in the reasoning plan using Pydantic. """
    plan: str = Field(..., description="The reasoning or the direct content/instruction for this step.")
    tool_call: Optional[ToolCallPydantic] = Field(None, description="The tool call for this step, or null if no tool is needed.")

class PlanOutputPydantic(BaseModel):
    """ Defines the structure for the entire plan generated by the LLM. """
    steps: List[PlanStepPydantic] = Field(..., description="The list of steps composing the plan.")
# --- End Pydantic Models ---


# --- TypedDict Definitions for State and Internal Use ---
class ToolCall(TypedDict):
    """ Represents a planned tool call within the ReWOO plan. """
    tool_name: str # e.g., "web_search_placeholder/search"
    arguments: Dict[str, Any]

class ToolResult(TypedDict):
    """ Represents the output of a tool execution. """
    tool_name: str
    output: Any # The actual data returned by the tool
    error: Optional[str] # Any error message during execution

class PlanStep(TypedDict):
    """ Represents a single step in the reasoning plan. """
    step_index: int # 필드 이름을 step_index로 변경 및 통일
    thought: str
    # tool_call 필드 타입을 Optional[ToolCall] 로 수정
    tool_call: Optional[ToolCall]
    expected_outcome: str
    status: str # 'pending', 'in_progress', 'completed', 'failed'

class Evidence(TypedDict):
    """ Represents the evidence gathered from a tool execution, linked to a plan step. """
    step_index: int # The index of the plan step this evidence corresponds to (matches PlanStep.step_index)
    tool_result: ToolResult # The result of the tool execution
    processed_evidence: str # A summary or processed form of the tool output (potentially LLM generated)

# Representing parsed plan steps as tuples (for actual tool execution)
# (reasoning: str, evidence_variable: str, tool_name: str, tool_input: str)
ParsedPlanStep = Tuple[str, str, str, str]

# Evidence dictionary mapping evidence variable (#E1, #E2) to its string content
EvidenceDict = Dict[str, str]

# LangGraph State Definition
class ReWOOState(TypedDict):
    """
    Represents the state of the ReWOO agent workflow.
    """
    original_query: str
    plan: Optional[List[ParsedPlanStep]] # Stores list of parsed tuples ONLY for tool calls
    plan_pydantic: Optional[PlanOutputPydantic] # Store the full parsed plan object from the parser
    all_parsed_steps: Optional[List[Dict[str, Any]]] # Keep for now, might be redundant later
    current_step_index: int
    # Removed tool_name, tool_input, tool_output as they are handled via current_tool_call/evidence
    # tool_name: str | None
    # tool_input: Dict[str, Any] | None
    # tool_output: Any | None # Can be string, dict, or other types depending on the tool
    current_tool_call: Optional[Dict[str, Any]] # Info for the tool currently being prepared/executed (tool_name, raw_input, evidence_var)
    prepared_tool_input: Optional[Any] # Input prepared by tool_input_preparer (after substitution)
    evidence: EvidenceDict # Dictionary to store results mapped by evidence_var (#E1, #E2, etc.)
    final_answer: Optional[str]
    error_message: Optional[str]
    max_retries: int
    current_retry: int # Renamed from retries for clarity
    workflow_status: Optional[str] # Use Optional for initial state
    next_node: Optional[str]

# Pydantic models removed as we parse plan text now
# class ToolCallPydantic(BaseModel): ...
# class PlanStepPydantic(BaseModel): ...
# class PlanOutput(BaseModel): ... 