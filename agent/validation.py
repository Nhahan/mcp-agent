# agent/validation.py
from typing import List, Dict, Any, Tuple, Set, Optional
import re

from .state import PlanStep, ToolCall

# Define potential validation issues
ValidationIssue = Tuple[int, str] # (step_index, issue_description)

class PlanValidator:
    """ Validates the structural integrity and logical coherence of a generated plan. """

    def __init__(self, available_tool_names: Optional[List[str]] = None):
        """ Initializes the validator with available tool names for checking. """
        self.available_tool_names: Set[str] = set(available_tool_names) if available_tool_names else set()

    def validate(self, plan: List[PlanStep]) -> Tuple[bool, List[ValidationIssue]]:
        """
        Validates the entire plan.

        Args:
            plan: The list of PlanStep objects to validate.

        Returns:
            A tuple containing:
            - bool: True if the plan is valid, False otherwise.
            - List[ValidationIssue]: A list of identified validation issues.
        """
        issues: List[ValidationIssue] = []
        is_valid = True

        if not plan:
            issues.append((-1, "Plan is empty."))
            return False, issues

        evidence_map: Set[str] = set() # To track defined evidence (#E<n>)
        expected_indices = set(range(len(plan)))
        actual_indices = set()

        for i, step in enumerate(plan):
            step_index = step.get('step_index')
            if step_index is None:
                # If index is missing from step, use loop index for reporting
                reporting_index = i
                issues.append((reporting_index, "Step is missing 'step_index'."))
                is_valid = False
            else:
                reporting_index = step_index
                if not isinstance(step_index, int) or step_index < 0:
                     issues.append((reporting_index, f"Invalid 'step_index' value: {step_index}"))
                     is_valid = False
                elif step_index in actual_indices:
                    issues.append((reporting_index, f"Duplicate step_index found: {step_index}"))
                    is_valid = False
                else:
                    actual_indices.add(step_index)

            # Use reporting_index for associating issues with a step
            step_issues = self._validate_step(step, evidence_map, reporting_index)
            if step_issues:
                is_valid = False
                issues.extend([(reporting_index, issue) for issue in step_issues])

            # Track evidence generated by this step's tool call
            # Assume #E<n> corresponds to step_index + 1 for now
            # This might need adjustment based on how planner/parser assigns #E numbers
            if step.get('tool_call') and reporting_index >= 0: # Only track if index is valid
                evidence_map.add(f"#E{reporting_index + 1}")

        # Check for missing or extra indices
        missing_indices = expected_indices - actual_indices
        extra_indices = actual_indices - expected_indices
        if missing_indices:
            is_valid = False
            issues.append((-1, f"Plan is missing step indices: {sorted(list(missing_indices))}"))
        if extra_indices:
            is_valid = False
            issues.append((-1, f"Plan has unexpected step indices: {sorted(list(extra_indices))}"))

        # TODO: Add cross-step validation (e.g., logical flow, evidence usage)

        return is_valid, issues

    def _validate_step(self, step: PlanStep, defined_evidence: Set[str], reporting_index: int) -> List[str]:
        """ Validates a single step in the plan. reporting_index is for error association. """
        step_issues: List[str] = []

        # 1. Check thought
        if not step.get('thought') or not isinstance(step.get('thought'), str):
            step_issues.append("Step is missing a valid 'thought' (string).")

        # 2. Validate Tool Call (if present)
        tool_call = step.get('tool_call')
        if tool_call is not None:
            if not isinstance(tool_call, dict):
                 step_issues.append("'tool_call' field must be a dictionary or None.")
            else:
                tool_name = tool_call.get('tool_name')
                arguments = tool_call.get('arguments')

                if not tool_name or not isinstance(tool_name, str):
                    step_issues.append("Tool call is missing a valid 'tool_name' (string).")
                elif self.available_tool_names and tool_name not in self.available_tool_names:
                    # Only validate if available_tool_names were provided
                    step_issues.append(f"Tool '{tool_name}' is not available. Available: {list(self.available_tool_names)}")

                if arguments is None: # Allow empty dict {} but not None
                    step_issues.append("Tool call is missing 'arguments' dictionary (can be empty {}). Use None for no tool call.")
                elif not isinstance(arguments, dict):
                    step_issues.append("Tool call 'arguments' must be a dictionary.")
                else:
                    # 3. Validate Evidence Usage within arguments
                    try:
                        self._validate_argument_evidence(arguments, defined_evidence)
                    except ValueError as e:
                        step_issues.append(f"Invalid evidence reference in arguments: {e}")

        # 4. Validate Status
        status = step.get('status', 'pending') # Default to pending if missing
        if status not in ["pending", "success", "failed"]:
            step_issues.append(f"Invalid status: '{status}'. Must be one of: pending, success, failed.")

        # 5. Validate Expected Outcome (optional field)
        expected_outcome = step.get('expected_outcome')
        if expected_outcome is not None and not isinstance(expected_outcome, str):
             step_issues.append("'expected_outcome' must be a string or None.")


        return step_issues

    def _validate_argument_evidence(self, args: Any, defined_evidence: Set[str]):
        """ Recursively checks arguments for valid #E<n> references. Raises ValueError on invalid reference. """
        if isinstance(args, str):
            if args.startswith("#E"):
                # Simple validation: check if format #E<number> is correct
                if not re.fullmatch(r"#E\d+", args):
                    raise ValueError(f"Invalid evidence placeholder format: '{args}'. Expected #E<number>.")
                # Check if defined (using the assumption #E<n> maps to step_index n-1)
                if args not in defined_evidence:
                    raise ValueError(f"Evidence placeholder '{args}' used before definition or out of sequence. Defined evidence sources: {sorted(list(defined_evidence))}")
        elif isinstance(args, dict):
            for value in args.values():
                self._validate_argument_evidence(value, defined_evidence)
        elif isinstance(args, list):
            for item in args:
                self._validate_argument_evidence(item, defined_evidence)

# --- Example Usage --- (Needs update for new PlanStep structure)
if __name__ == "__main__":
    # Mock tools for validator initialization
    mock_available_tools = ["search/web_search", "knowledge/lookup"]
    validator = PlanValidator(mock_available_tools)

    # Example valid plan
    valid_plan: List[PlanStep] = [
        PlanStep(step_index=0, thought="Find capital", tool_call=ToolCall(tool_name="search/web_search", arguments={"query": "Capital of France"}), expected_outcome="Capital City", status="pending"),
        PlanStep(step_index=1, thought="Look up population using #E1", tool_call=ToolCall(tool_name="knowledge/lookup", arguments={"entity": "#E1"}), expected_outcome="Population Number", status="pending"),
    ]

    # Example invalid plan
    invalid_plan: List[PlanStep] = [
        # Missing step_index handled by validate()
        PlanStep(thought="Use wrong tool", tool_call=ToolCall(tool_name="calculator/add", arguments={}), status="pending"), # Tool not available
        PlanStep(step_index=1, thought="Reference future evidence #E3", tool_call=ToolCall(tool_name="search/web_search", arguments={"query": "#E3"}), status="pending"), # Evidence not defined yet
        PlanStep(step_index=2, thought="Missing arguments dict", tool_call=ToolCall(tool_name="knowledge/lookup", arguments=None), status="pending"), # Arguments is None
        PlanStep(step_index=3, tool_call=None, status="pending"), # Missing thought
        PlanStep(step_index=4, thought="Index mismatch in data", step_index=5, tool_call=None, status="pending"), # Index mismatch
        PlanStep(step_index=5, thought="Duplicate index", tool_call=None, status="pending"), # Duplicate index from step above
        PlanStep(step_index=6, thought="Invalid status", tool_call=None, status="running"), # Invalid status value
        PlanStep(step_index=7, thought="Invalid evidence format", tool_call=ToolCall(tool_name="search/web_search", arguments={"query": "#E"}), status="pending"), # Invalid #E format
        PlanStep(step_index=8, thought="Invalid args type", tool_call=ToolCall(tool_name="search/web_search", arguments=["list", "is", "wrong"]), status="pending"), # Args not dict
    ]

    print("--- Validating valid_plan ---")
    is_valid, issues = validator.validate(valid_plan)
    print(f"Is Valid: {is_valid}")
    print(f"Issues: {issues}")
    assert is_valid
    assert not issues

    print("\n--- Validating invalid_plan ---")
    is_valid, issues = validator.validate(invalid_plan)
    print(f"Is Valid: {is_valid}")
    print(f"Issues:")
    # Sort issues for consistent output
    for index, desc in sorted(issues):
        print(f"  Step Index {index}: {desc}")
    assert not is_valid
    assert len(issues) > 0
    print("\nValidation example finished.") 